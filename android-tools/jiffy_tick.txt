https://en.wikipedia.org/wiki/Jiffy_(time)
In computing, a jiffy was originally the time between two ticks of the system timer interrupt.[4] It is not an absolute time interval unit, since its duration depends on the clock interrupt frequency of the particular hardware platform.

http://man7.org/linux/man-pages/man7/time.7.html
the software clock maintained by the kernel which measures time in jiffies.

The size of a jiffy is determined by the value of the kernel constant HZ.

The times(2) system call is a special case.  It reports times with a
granularity defined by the kernel constant USER_HZ.  User-space
applications can determine the value of this constant using
sysconf(_SC_CLK_TCK).



programmable clocks typically have several modes of operation: one-shot mode
and square-wave mode. In square-wave mode, after counter getting to zero and
causing the interrupt, the holding register is automatically copied into the counter,
and the whole process is repeated again indefinitely. These periodic interrupts
are called clock ticks.

The quantum is the number of clock ticks the theread may continue to run for.
In the currect Linux version, the clock runs at 1000HZ, and each tick is 1ms,
which is called a jiffy


/proc/uptime
    fs/proc/uptime.c
        static int uptime_proc_show(struct seq_file *m, void *v)
        {
            struct timespec uptime;
            struct timespec idle;
            u64 idletime;
            u64 nsec;
            u32 rem;
            int i;

            idletime = 0;
            for_each_possible_cpu(i)
                idletime += (__force u64) kcpustat_cpu(i).cpustat[CPUTIME_IDLE];

                get_monotonic_boottime(&uptime);
                nsec = cputime64_to_jiffies64(idletime) * TICK_NSEC;
                idle.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);
                idle.tv_nsec = rem;
                seq_printf(m, "%lu.%02lu %lu.%02lu\n",
                        (unsigned long) uptime.tv_sec,
                        (uptime.tv_nsec / (NSEC_PER_SEC / 100)),
                        (unsigned long) idle.tv_sec,
                        (idle.tv_nsec / (NSEC_PER_SEC / 100)));
                return 0;
        }


    ./include/asm-generic/param.h
        #ifndef __ASM_GENERIC_PARAM_H
        #define __ASM_GENERIC_PARAM_H

        #include <uapi/asm-generic/param.h>

        # undef HZ
        # define HZ     CONFIG_HZ   /* Internal kernel timer frequency */
        # define USER_HZ    100     /* some user interfaces are */
        # define CLOCKS_PER_SEC (USER_HZ)       /* in "ticks" like times() */
        #endif /* __ASM_GENERIC_PARAM_H */

    include/linux/timekeeping.h
        /**
         * ktime_get_boottime - Returns monotonic time since boot in ktime_t format
         *
         * This is similar to CLOCK_MONTONIC/ktime_get, but also includes the
         * time spent in suspend.
         */
        static inline ktime_t ktime_get_boottime(void) {
             return ktime_get_with_offset(TK_OFFS_BOOT);
        }

        /*
         * Timespec interfaces utilizing the ktime based ones
         */
        static inline void get_monotonic_boottime(struct timespec *ts) {
            *ts = ktime_to_timespec(ktime_get_boottime());
        }

        static inline void get_monotonic_boottime64(struct timespec64 *ts)
        {
            *ts = ktime_to_timespec64(ktime_get_boottime());
        }


    include/linux/ktime.h
        /* Map the ktime_t to timespec conversion to ns_to_timespec function */
        #define ktime_to_timespec(kt)       ns_to_timespec((kt).tv64)

        /* Map the ktime_t to timespec conversion to ns_to_timespec function */
        #define ktime_to_timespec64(kt)     ns_to_timespec64((kt).tv64)



About the process start time in /proc/pid/stat:
http://man7.org/linux/man-pages/man5/proc.5.html
(22) starttime  %llu
    The time the process started after system boot.  In
    kernels before Linux 2.6, this value was expressed
    in jiffies.  Since Linux 2.6, the value is expressed
    in clock ticks (divide by sysconf(_SC_CLK_TCK)).

    The format for this field was %lu before Linux 2.6.

kernel side source:
    fs/proc/base.c
        static const struct pid_entry tgid_base_stuff[] = {
            ...
            ONE("stat",       S_IRUGO, proc_tgid_stat),
            ...
        }

    fs/proc/array.c
        int proc_tgid_stat(struct seq_file *m, struct pid_namespace *ns,
            struct pid *pid, struct task_struct *task)
        {
            return do_task_stat(m, ns, pid, task, 1);
        }

        static int do_task_stat(struct seq_file *m, struct pid_namespace *ns,
            struct pid *pid, struct task_struct *task, int whole)
        {
            ...
            unsigned long long start_time;
            ...
            /* convert nsec -> ticks */
            start_time = nsec_to_clock_t(task->real_start_time);
            ...
            seq_put_decimal_ull(m, " ", start_time);
            ...
        }

    kernel/fork.c
        static __latent_entropy struct task_struct *copy_process(...){
            ...
            p->start_time = ktime_get_ns();
            p->real_start_time = ktime_get_boot_ns();
            ...
        }
    include/linux/timekeeping.h
        static inline u64 ktime_get_ns(void) {
            return ktime_to_ns(ktime_get());
        }
        static inline u64 ktime_get_boot_ns(void) {
            return ktime_to_ns(ktime_get_boottime());
        }

    include/linux/ktime.h:115:#define ktime_to_ns(kt)           ((kt).tv64)

    kernel/time/time.c
        u64 nsec_to_clock_t(u64 x)
        {
        #if (NSEC_PER_SEC % USER_HZ) == 0
            return div_u64(x, NSEC_PER_SEC / USER_HZ);
        #elif (USER_HZ % 512) == 0
            return div_u64(x * USER_HZ / 512, NSEC_PER_SEC / 512);
        #else
            /*
             * max relative error 5.7e-8 (1.8s per year) for USER_HZ <= 1024,
             * overflow after 64.99 years.
             * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...
             */
            return div_u64(x * 9, (9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ);
        #endif
        }

    include/linux/time64.h:36:#define NSEC_PER_SEC  1000000000L
    include/asm-generic/param.h
        # undef HZ
        # define HZ     CONFIG_HZ   /* Internal kernel timer frequency */
        # define USER_HZ    100     /* some user interfaces are */
        # define CLOCKS_PER_SEC (USER_HZ)       /* in "ticks" like times() */

